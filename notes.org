* Chapter 1
** Beta normal form is when you cannot beta reduce (apply lambdas to arguments) the terms any further. 
** Lambda calculus is a formal system for expressing programs in terms of abstraction and application.
* Chapter 2
   * /Reducing/ an expression means evaluating the terms until you’re left with a value
   * Expression is in canonical or /normal form/ when it reaches the number 6 because the value 6 has no remaining reducible expressions. 
Haskell’s nonstrict evaluation means not everything will get reduced to its irreducible form immediately, so this:
 ~(\f -> (1, 2 + f)) 2~
reduces to the following in WHNF:
 ~(1, 2 + 2)~
   * /let/ introduces an expression, so it can be used wherever you can have an expression, but /where/ is a declaration and is bound to a surrounding syntactic construct.
   *  In Haskell, an /expression/ is a well-structured combination of constants, variables, and functions.
* Chapter 4
    * /Data declarations/ are how datatypes are defined.
    * /The type constructor/ is the name of the type and is capitalized.
    * Data constructors are the values that inhabit the type they are defined in.
    * Example of data desclaration:
   #+BEGIN_SRC haskell
   data Bool = False | True
   --   [1]     [2] [3] [4]
   #+END_SRC 
   1. Type constructor for datatype Bool. This is the name of the type and shows up in type signatures.
   2. Data constructor for the value False.
   3. Pipe | indicates a sum type or logical disjunction: “or.” So, a Bool value is True or False.
   4. Data constructor for the value True.
** Numeric types:
   1. Integral Numbers:
      1. Int
      2. Integer
   2. Fractional
      1. Float
      2. Double
      3. Rational
** Typeclass
   * /Typeclass/ is a set of operations defined with respect to a polymorphic type.
   When a type is an instance of a typeclass, values of that type can be used in the standard operations defined for that typeclass. In Haskell, typeclasses are unique pairings of class and concrete instance. This means that if a given type a has an instance of Eq, it has only one instance of Eq.
* Chapter 5
    * In Haskell, you cannot create untyped data, so except for a sprinkling of syntactic sugar for things like numbers or functions, everything originates in a data constructor from some definition of a type.
    * The arrow, ~(->)~, is the *type constructor* for functions in Haskell.
#+BEGIN_SRC haskell
(Ord a, Num a) => a -> a -> Ordering
#+END_SRC
    Here, the constraints look like a tuple but they don’t add another function argument that you must provide, and they don’t appear as a tuple at the value or term level. Nothing to the left of the type-class arrow, =>, shows up at term level. The tuple of constraints does represent a product, or conjunction, of constraints.
    Compare:
   #+BEGIN_SRC haskell
       Prelude> :info (->)
       data (->) a b

     -- If you compare this to the type constructor for the two-tuple, you
     -- see the similarity:
       Prelude> :info (,)
       data (,) a b = (,) a b
   #+END_SRC
   Unlike the tuple constructor, though, the function type has no data constructors. The value that shows up at term level is the function. 
   * /Functions are values./
   The parameterization suggests that we will apply the function to some argument that will be bound to the first parameter, with the second parameter, b, representing the return or result type.
** Type signature constraints
   * Example - ~(Ord a, Num a) => a -> a -> Ordering~
   Here, the constraints look like a tuple but they don’t add another function argument that you must provide, and they don’t appear as a tuple at the value or term level. Nothing to the left of the type-class arrow, =>, shows up at term level. The tuple of constraints does represent a product, or conjunction, of constraints.
    * The way the ~(->)~ type constructor for functions works means ~a -> a -> a~ represents successive function applications, each taking one argument and returning one result. The difference is that the function at the outermost layer is actually returning another function that accepts the next argument. This is called currying.
    * Explicit parenthesization, as when an input parameter is itself a function (such as in map, above), may be used to indicate order of evaluation, but the implicit associativity of the function type does not mean the inner or final set of parentheses, i.e., the result type, evaluates first. Application is evaluation; in other words, the only way to evaluate anything is by applying functions, and function applica- tion is left associative. So, the leftmost, or outermost, arguments will be evaluated first, assuming anything gets evaluated (since Haskell is nonstrict, you can’t assume that anything will be evaluated, but this will be more clear later).
Also - https://stackoverflow.com/questions/36143423/right-associativity-in-type-signatures-of-functions
** Partial Application
   * ~(2^)~ (left section) is equivalent to ~(^) 2~ , or more verbosely ~\x -> 2 ^ x~
   * ~(^2)~ (right section) is equivalent to ~flip (^) 2~ , or more verbosely ~\x -> x ^ 2~
   * More - https://wiki.haskell.org/Section_of_an_infix_operator
Partial application is common enough in Haskell that, over time, you’ll develop an intuition for it. The sectioning syntax exists to allow some freedom in which argument of a binary operator you apply the function to.
** Polymorphism
   * Type signatures may have three kinds of types: concrete, constrained polymorphic, or parametrically polymorphic.
   * /Constrained/ = Ad-hoc polymorphyc. Ad-hoc polymorphism in Haskell is implemented with typeclasses.
   * /Typeclass constraints/ limit the set of potential types (and, thus, potential values) while also passing along the common functions that can be used with those values.
   * /Parametricity/ means that the behavior of a function with respect to the types of its (parametrically polymorphic) arguments is uniform.
   Parametricity is the property we get from having parametric polymorphism.
** Type inference
   * Haskell’s type inference is built on an extended version of the /Damas-Hindley-Milner/ type system.

* Chapter 6
** Haskell and purity (Show typeclass section)
   * /Side effect/ -- a potentially observable result apart from the value the expression evaluates to.
   Haskell manages effects by separating effectful computations from pure computations in ways that preserve the predictability and safety of function evaluation. Importantly, effect-bearing computations themselves become more composable and easier to reason about. The benefits of explicit effects include the fact that it makes it relatively easy to reason about and predict the results of our functions.
   * ~main~ has IO () type because ~main` /only/ produces side effects.
   * /IO/ is the type for values whose evaluation bears the possibility of causing side effects, such as printing text, reading text input from the user, reading or writing files, or connecting to remote computers.
** Instances are dispatched by type
* Chapter 7
** Interesting point about lambda functions
   > We won’t go into a lot of detail about this yet, but named entities and anonymous entities evaluate a bit differently in Haskell, and that can be one reason to use an anonymous function in some cases.
* Chapter 8
** Y-combinator
   * We use a combinator – known as the /Y combinator/ or fixed-point combinator – to write recursive functions in the lambda calculus. Haskell has native recursion ability based on the same principle as the Y combinator.
   * Also - http://mvanier.livejournal.com/2897.html
