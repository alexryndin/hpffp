* Chapter 1
** Beta normal form is when you cannot beta reduce (apply lambdas to arguments) the terms any further. 
** Lambda calculus is a formal system for expressing programs in terms of abstraction and application.
* Chapter 2
** Reducing an expression means evaluating the terms until you’re left with a value
** Expression is in canonical or /normal form/ when it reaches the number 6 because the value 6 has no remaining reducible expressions. 
Haskell’s nonstrict evaluation means not everything will get reduced to its irreducible form immediately, so this:
 ~(\f -> (1, 2 + f)) 2~
reduces to the following in WHNF:
 ~(1, 2 + 2)~
** /let/ introduces an expression, so it can be used wherever you can have an expression, but /where/ is a declaration and is bound to a surrounding syntactic construct.
**  In Haskell, an /expression/ is a well-structured combination of constants, variables, and functions.
* Chapter 4
** /Data declarations/ are how datatypes are defined.
** The type constructor is the name of the type and is capitalized.
** Data constructors are the values that inhabit the type they are defined in.
** Example of data desclaration:
   data Bool = False | True
   --   [1]     [2] [3] [4]
   1. Type constructor for datatype Bool. This is the name of the type and shows up in type signatures.
   2. Data constructor for the value False.
   3. Pipe | indicates a sum type or logical disjunction: “or.” So, a Bool value is True or False.
   4. Data constructor for the value True.
** Numeric types:
   1. Integral Numbers:
      1. Int
      2. Integer
   2. Fractional
      1. Float
      2. Double
      3. Rational
** A typeclass is a set of operations defined with respect to a polymorphic type.
   When a type is an instance of a typeclass, values of that type can be used in the standard operations defined for that typeclass. In Haskell, typeclasses are unique pairings of class and concrete instance. This means that if a given type a has an instance of Eq, it has only one instance of Eq.
* Chapter 5
** In Haskell, you cannot create untyped data, so except for a sprinkling of syntactic sugar for things like numbers or functions, everything originates in a data constructor from some definition of a type.
** The arrow, (->), is the type constructor for functions in Haskell.
   Compare:
   #+BEGIN_SRC haskell
       Prelude> :info (->)
       data (->) a b

     -- If you compare this to the type constructor for the two-tuple, you
     -- see the similarity:
       Prelude> :info (,)
       data (,) a b = (,) a b
   #+END_SRC
   Unlike the tuple constructor, though, the function type has no data constructors. The value that shows up at term level is the function. 
   /Functions are values./
   The parameterization suggests that we will apply the function to some argument that will be bound to the first parameter, with the second parameter, b, representing the return or result type.
** The way the ~(->)~ type constructor for functions works means ~a -> a -> a~ represents successive function applications, each taking one argument and returning one result. The difference is that the function at the outermost layer is actually returning another function that accepts the next argument. This is called currying.
Explicit parenthesization, as when an input parameter is itself a function (such as in map, above), may be used to indicate order of evaluation, but the implicit associativity of the function type does not mean the inner or final set of parentheses, i.e., the result type, evaluates first. Application is evaluation; in other words, the only way to evaluate anything is by applying functions, and function applica- tion is left associative. So, the leftmost, or outermost, arguments will be evaluated first, assuming anything gets evaluated (since Haskell is nonstrict, you can’t assume that anything will be evaluated, but this will be more clear later).
Also - https://stackoverflow.com/questions/36143423/right-associativity-in-type-signatures-of-functions
